ng-template('#slides'='')
    tables-of-content-concepts([active]="conceptLabels.KERNEL_TRICK")
    section
        slide-with-header(header="Kernel Trick - Intuition")
            h6 Reminder Feature Engineering:
            div.mt-5.d-flex.justify-center.fragment
                model-3-visualization("#featureEngineering"="", input-header="Input Space", feature-header="Feature Space", output-header="Output Space" )
                    div(input).rect-styling
                        div([mathjax]="inputs")
                    div(pre).model-box Feature Engineering
                    div(feature).rect-styling
                        div([mathjax]="features")
                    div(model).model-box Modell
                    div(output).rect-styling
                        div([mathjax]="outputs")
                span.fragment(fragment-trigger, (trigger)="featureEngineering.end()")
            div.fragment
                h6.mt-5 Kernel-Trick macht #[span.highlight implizites Feature Engineering] (mit anderem Rechenaufwand)
                div.d-flex.justify-center
                    model-3-visualization("#kernelTrick"="", input-header="Input Space", feature-header="Feature Space", output-header="Output Space", [with-trigger]="false")
                        div(input).rect-styling
                            div([mathjax]="inputs")
                        div(pre, style={borderColor: "#C0C0C0", backgroundColor: "lightgray"}).model-box Feature Engineering
                        div(feature, style={opacity: 0.25}).rect-styling
                            div([mathjax]="features")
                        div(model).model-box SVM
                        div(output).rect-styling
                            div([mathjax]="outputs")
            div.mt-5.fragment.text-center.alert.alert-primary
                div (Meistens) #[span.highlight gleicher Effekt], #[span.highlight anderes Verfahren]
    section
        slide-with-header(header="Kernel Trick - Representer Theorem", [extra]="true")
            ul(style={fontSize: "22pt"})
                li.fragment
                    div #[span.highlight Gewicht pro Datenpunkt], anstatt #[span.highlight Gewicht pro Feature] ist äquivalent
                    div([mathjax]="representerTheorem")
                li.fragment Änderung auf das z.B. Linear Modell (Dual Form)
                    div([mathjax]="linearModelDualFormDerivation")
                li.fragment
                    div Wir können also #[span.code N]&nbsp;#[span(mathjax="<math><mi>α</mi></math>")]'s lernen anstatt #[span.code M]&nbsp;#[span(mathjax="<math><mi>β</mi></math>")]'s (#[span.code N] = Anzahl Datenpunkte, #[span.code M] = Anzahl Features) und lernen das von aussen #[span.highlight identische Modell]
                li.fragment Anzahl lernbare Parameter nicht mehr abhängig von Anzahl Features. Gut wenn #[span.code M] >> #[span.code N]
    section
        slide-with-header(header="Kernel Trick - Kernel", [extra]="true")
            ul
                li
                    div In der Dual-Form misst das Dot-Product (#[span(mathjax="<math><msup><mi>x</mi><mi>(i)</mi></msup><mi>x</mi></math>")]) die #[span.highlight Distanz] vom neuen Datenpunkt (#[span(mathjax="<math><mi>x</mi></math>")]) zum Train-Set-Datenpunkten (#[span(mathjax="<math><msup><mi>x</mi><mi>(i)</mi></msup></math>")]):
                    div([mathjax]="linearModelDualFormHighlight")
                li #[span.highlight Kernel Trick]: Diese Messung von Distanz so verändern, dass es #[span.highlight der Distanz im Feature Space] entspricht
    section
        slide-with-header(header="Kernel Trick - Beispiel", [extra]="true")
            div([mathjax]="linearModelDualFormKernel")
            ul
                li Kernel #[span([mathjax]="kernel")] misst die Distanz vom neuen Datenpunkt zum Train-Set-Datenpunkten.
            div.mt-5.fragment.text-center.alert.alert-primary In der Praxis wird der Kernel-Trick meistens #[span.highlight nur mit der SVM] eingesetzt.
    section
        slide-with-header(header="Kernel Trick - Most Common Kernels", [extra]="true")
            side-by-side-3
                div(first)
                    h5 Linear
                    div([mathjax]="linearKernel")
                    img(src="assets/images/classification/svm/support-vector-machine-linear-support-vectors-2d.png")
                div(second)
                    h5 Polynomial
                    div([mathjax]="polynomialKernel")
                    img(src="assets/images/classification/svm/support-vector-machine-poly-support-vectors-2d.png")
                div(third)
                    h5 RBF
                    div([mathjax]="rbfKernel")
                    img(src="assets/images/classification/svm/support-vector-machine-rbf-support-vectors-2d.png")
            div.mt-5.fragment.text-center.alert.alert-primary Kernel macht die Modelle nicht linear.
    section
        slide-with-header(header="Support Vector Machine (und Kernel Trick) - Code")
            div.notebook-name support_vector_machine.ipynb
            img(src="assets/images/code.png")